{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 111, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/firebase.ts"],"sourcesContent":["\nimport { initializeApp, getApp, getApps, type FirebaseApp } from \"firebase/app\";\nimport { getFirestore, type Firestore } from \"firebase/firestore\";\n\n// Minimal logging\nconsole.log(\"[firebase.ts] Initializing Firebase...\");\n\nconst firebaseConfig = {\n  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,\n  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,\n  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,\n  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,\n  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,\n  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,\n};\n\nif (!firebaseConfig.projectId || !firebaseConfig.apiKey) {\n  console.error(\"[firebase.ts] FATAL ERROR: Firebase projectId or apiKey is MISSING in environment variables.\");\n}\n\nlet app: FirebaseApp;\nlet db: Firestore;\n\nif (getApps().length === 0) {\n  try {\n    app = initializeApp(firebaseConfig);\n    console.log(\"[firebase.ts] Firebase app initialized. Project ID:\", app.options.projectId);\n  } catch (e: any) {\n    console.error(\"[firebase.ts] FAILED to initialize Firebase app:\", e.message);\n    // @ts-ignore\n    app = null;\n  }\n} else {\n  app = getApp();\n  console.log(\"[firebase.ts] Using existing Firebase app. Project ID:\", app.options.projectId);\n}\n\n// @ts-ignore\nif (app) {\n  try {\n    // @ts-ignore\n    db = getFirestore(app);\n    console.log(\"[firebase.ts] Firestore instance obtained.\");\n  } catch (e: any) {\n    console.error(\"[firebase.ts] FAILED to get Firestore instance:\", e?.message);\n  }\n} else {\n    console.error(\"[firebase.ts] Firebase app not properly initialized, cannot get Firestore.\");\n}\n\nexport { app, db };\n"],"names":[],"mappings":";;;;AACA;AAAA;AACA;AAAA;;;AAEA,kBAAkB;AAClB,QAAQ,GAAG,CAAC;AAEZ,MAAM,iBAAiB;IACrB,MAAM;IACN,UAAU;IACV,SAAS;IACT,aAAa;IACb,iBAAiB;IACjB,KAAK;AACP;AAEA,IAAI,CAAC,eAAe,SAAS,IAAI,CAAC,eAAe,MAAM,EAAE;IACvD,QAAQ,KAAK,CAAC;AAChB;AAEA,IAAI;AACJ,IAAI;AAEJ,IAAI,CAAA,GAAA,oLAAA,CAAA,UAAO,AAAD,IAAI,MAAM,KAAK,GAAG;IAC1B,IAAI;QACF,MAAM,CAAA,GAAA,oLAAA,CAAA,gBAAa,AAAD,EAAE;QACpB,QAAQ,GAAG,CAAC,uDAAuD,IAAI,OAAO,CAAC,SAAS;IAC1F,EAAE,OAAO,GAAQ;QACf,QAAQ,KAAK,CAAC,oDAAoD,EAAE,OAAO;QAC3E,aAAa;QACb,MAAM;IACR;AACF,OAAO;IACL,MAAM,CAAA,GAAA,oLAAA,CAAA,SAAM,AAAD;IACX,QAAQ,GAAG,CAAC,0DAA0D,IAAI,OAAO,CAAC,SAAS;AAC7F;AAEA,aAAa;AACb,IAAI,KAAK;IACP,IAAI;QACF,aAAa;QACb,KAAK,CAAA,GAAA,iKAAA,CAAA,eAAY,AAAD,EAAE;QAClB,QAAQ,GAAG,CAAC;IACd,EAAE,OAAO,GAAQ;QACf,QAAQ,KAAK,CAAC,mDAAmD,GAAG;IACtE;AACF,OAAO;IACH,QAAQ,KAAK,CAAC;AAClB","debugId":null}},
    {"offset": {"line": 264, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/genkit.ts"],"sourcesContent":["\nimport '@/lib/firebase'; // Ensure Firebase is initialized early\nimport {genkit} from 'genkit';\nimport {googleAI} from '@genkit-ai/googleai'; // Impor plugin Google AI\n\nif (!process.env.GOOGLE_API_KEY) {\n  const errorMessage = \"Kesalahan Konfigurasi: GOOGLE_API_KEY tidak ditemukan di environment variables. Ini dibutuhkan oleh plugin Google AI. Pastikan sudah di-set di file .env Anda.\";\n  console.error(`\\n\\n🛑 ${errorMessage}\\n\\n`);\n  throw new Error(errorMessage);\n}\n\nexport const ai = genkit({\n  plugins: [\n    googleAI(), // Gunakan plugin Google AI\n  ],\n  model: 'googleai/gemini-1.5-flash-latest', // Mengubah ke model yang lebih stabil\n  // Opsi telemetry tidak lagi dikonfigurasi di sini untuk Genkit v1.x\n  // Jika butuh logging, konfigurasi dilakukan secara berbeda atau via environment.\n});\n\n"],"names":[],"mappings":";;;AACA,8MAAyB,uCAAuC;AAChE;AAAA;AACA,8TAA8C,yBAAyB;AAAvE;;;;AAEA,IAAI,CAAC,QAAQ,GAAG,CAAC,cAAc,EAAE;IAC/B,MAAM,eAAe;IACrB,QAAQ,KAAK,CAAC,CAAC,OAAO,EAAE,aAAa,IAAI,CAAC;IAC1C,MAAM,IAAI,MAAM;AAClB;AAEO,MAAM,KAAK,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE;IACvB,SAAS;QACP,CAAA,GAAA,2KAAA,CAAA,WAAQ,AAAD;KACR;IACD,OAAO;AAGT","debugId":null}},
    {"offset": {"line": 292, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/tools/extractMotorInfoTool.ts"],"sourcesContent":["\n'use server';\n/**\n * @fileOverview Genkit tool for extracting motorcycle information from text.\n * - extractMotorInfoTool - The Genkit tool definition.\n */\n\nimport { ai } from '@/ai/genkit';\nimport { z } from 'genkit';\nimport { db } from '@/lib/firebase'; // Use client-side SDK\nimport { collection, getDocs, query } from 'firebase/firestore'; // Use client-side SDK functions\n\n// Skema input untuk tool\nconst ExtractMotorInfoInputSchema = z.object({\n  text: z.string().describe('Teks dari pengguna yang mungkin berisi nama atau deskripsi motor.'),\n});\nexport type ExtractMotorInfoInput = z.infer<typeof ExtractMotorInfoInputSchema>;\n\n// Skema output untuk tool\nconst ExtractMotorInfoOutputSchema = z.object({\n  brand: z.string().describe('Merek motor yang terdeteksi.'),\n  model: z.string().describe('Model motor yang terdeteksi.'),\n  size: z.enum(['S', 'M', 'L', 'XL']).describe('Ukuran motor yang terdeteksi (S, M, L, XL).'),\n});\nexport type ExtractMotorInfoOutput = z.infer<typeof ExtractMotorInfoOutputSchema>;\n\n// Definisi tool Genkit\nexport const extractMotorInfoTool = ai.defineTool(\n  {\n    name: 'extractMotorInfoTool', // Nama tool di Genkit, bisa beda dari nama variabel\n    description: 'Mendeteksi merek, model, dan ukuran motor dari teks deskriptif pengguna dengan mencocokkan ke database tipe kendaraan.',\n    inputSchema: ExtractMotorInfoInputSchema,\n    outputSchema: ExtractMotorInfoOutputSchema,\n  },\n  async (input: ExtractMotorInfoInput): Promise<ExtractMotorInfoOutput> => {\n    // Firebase client 'db' is imported. It's assumed to be initialized.\n    // Error handling for db initialization is in '@/lib/firebase.ts'.\n    // If db itself is null/undefined, getDocs will throw.\n\n    const cleanText = input.text.toLowerCase().trim();\n    console.log(`[extractMotorInfoTool] Input text: \"${input.text}\", Cleaned text: \"${cleanText}\"`);\n\n    if (!cleanText) {\n      console.log('[extractMotorInfoTool] Input text is empty. Throwing error.');\n      throw new Error('Teks input kosong, tidak bisa mendeteksi motor.');\n    }\n\n    try {\n      const vehicleTypesCollectionRef = collection(db, 'vehicleTypes');\n      const vehicleTypesSnapshot = await getDocs(vehicleTypesCollectionRef);\n      console.log(`[extractMotorInfoTool] Raw snapshot size from 'vehicleTypes': ${vehicleTypesSnapshot.size}`);\n\n      if (vehicleTypesSnapshot.empty) {\n        console.log('[extractMotorInfoTool] Collection \"vehicleTypes\" is empty or does not exist in Firestore.');\n        throw new Error('Database tipe kendaraan kosong atau tidak ditemukan.');\n      }\n\n      const mappedVehicleTypes = vehicleTypesSnapshot.docs.map(doc => {\n        const data = doc.data();\n        const validationErrorMessages: string[] = [];\n\n        if (!data.brand || typeof data.brand !== 'string') {\n            validationErrorMessages.push('field \"brand\" is missing or not a string');\n        }\n        if (!data.model || typeof data.model !== 'string') {\n            validationErrorMessages.push('field \"model\" is missing or not a string');\n        }\n        if (!data.size || typeof data.size !== 'string' || !['S', 'M', 'L', 'XL'].includes(data.size)) {\n            validationErrorMessages.push('field \"size\" is missing, not a string, or not S/M/L/XL');\n        }\n        if (!data.aliases || !Array.isArray(data.aliases)) {\n            validationErrorMessages.push('field \"aliases\" is missing or not an array');\n        } else if (!data.aliases.every((a: any) => typeof a === 'string')) {\n            validationErrorMessages.push('field \"aliases\" contains non-string elements');\n        }\n\n        if (validationErrorMessages.length > 0) {\n            console.warn(`[extractMotorInfoTool] Dokumen ${doc.id} di 'vehicleTypes' GAGAL VALIDASI. Alasan: ${validationErrorMessages.join('; ')}. Data mentah: ${JSON.stringify(data)}. Dokumen ini akan dilewati.`);\n            return null; \n        }\n        \n        return {\n          id: doc.id,\n          brand: data.brand as string,\n          model: data.model as string,\n          size: data.size as 'S' | 'M' | 'L' | 'XL',\n          aliases: (data.aliases as string[]).map(alias => alias.toLowerCase()),\n        };\n      });\n      \n      console.log(`[extractMotorInfoTool] Mapped vehicle types (before filtering nulls): ${mappedVehicleTypes.length}`);\n      const allVehicleTypes = mappedVehicleTypes.filter(item => item !== null) as { id: string; brand: string; model: string; size: 'S' | 'M' | 'L' | 'XL'; aliases: string[]; }[];\n      \n      console.log(`[extractMotorInfoTool] Total valid vehicle types after filtering: ${allVehicleTypes.length}.`);\n\n      if (allVehicleTypes.length === 0) {\n        console.log('[extractMotorInfoTool] No valid vehicle types found after filtering. Check Firestore data format and console warnings above for details on invalid documents.');\n        throw new Error('Tidak ada data tipe kendaraan yang valid di database. Periksa format data di Firestore dan log peringatan di konsol.');\n      }\n\n      for (const vehicleType of allVehicleTypes) {\n        for (const alias of vehicleType.aliases) {\n          if (cleanText.includes(alias)) {\n            console.log(`[extractMotorInfoTool] !!! MATCH FOUND !!! Alias \"${alias}\" (from vehicle: ${vehicleType.brand} ${vehicleType.model}) found in cleaned text: \"${cleanText}\"`);\n            return {\n              brand: vehicleType.brand,\n              model: vehicleType.model,\n              size: vehicleType.size,\n            };\n          }\n        }\n      }\n\n      console.log('[extractMotorInfoTool] No match found for the input text after checking all vehicle types and aliases.');\n      throw new Error('Motor tidak dikenali dari teks yang diberikan. Pastikan alias di database mencakup variasi nama motor tersebut.');\n\n    } catch (error: any) {\n      console.error('[extractMotorInfoTool] Error during execution:', error);\n      if (error instanceof Error) {\n        throw new Error(`Kesalahan pada tool extractMotorInfo: ${error.message}`);\n      }\n      throw new Error(`Terjadi kesalahan internal pada tool extractMotorInfo: ${String(error)}`);\n    }\n  }\n);\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 425, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/tools/searchServiceByKeywordTool.ts"],"sourcesContent":["\n'use server';\n/**\n * @fileOverview Genkit tool for searching services by keyword and optional size/paint type.\n * - searchServiceByKeywordTool - The Genkit tool definition.\n */\nimport { ai } from '@/ai/genkit';\nimport { z } from 'genkit';\nimport { db } from '@/lib/firebase'; // Use client-side SDK\nimport { collection, getDocs, query as firestoreQuery } from 'firebase/firestore'; // Use client-side SDK functions\nimport type { ServiceProduct } from '@/app/(app)/services/page'; // Assuming this type is suitable\n\nconst SearchServiceInputSchema = z.object({\n  keyword: z.string().describe(\"Kata kunci untuk mencari layanan, mis. 'cuci', 'coating', 'nmax'.\") ,\n  size: z.enum(['S', 'M', 'L', 'XL']).optional().describe(\"Ukuran motor (S, M, L, XL) jika spesifik.\"),\n  paintType: z.enum(['doff', 'glossy']).optional().describe(\"Jenis cat motor (doff atau glossy) jika relevan, terutama untuk coating.\"),\n});\nexport type SearchServiceInput = z.infer<typeof SearchServiceInputSchema>;\n\nconst SearchServiceOutputSchema = z.object({\n  name: z.string().describe(\"Nama layanan yang ditemukan.\"),\n  description: z.string().optional().describe(\"Deskripsi layanan.\"),\n  price: z.number().optional().describe(\"Harga layanan untuk ukuran/jenis cat yang cocok (jika ada).\"),\n  size: z.enum(['S', 'M', 'L', 'XL']).optional().describe(\"Ukuran motor yang dicari (jika relevan dengan varian).\"),\n  duration: z.string().optional().describe(\"Estimasi durasi pengerjaan layanan.\"),\n  variantMatched: z.string().optional().describe(\"Nama varian yang cocok (jika ada dan relevan, mis. 'Doff', 'Glossy', 'Ukuran M - Doff').\")\n});\nexport type SearchServiceOutput = z.infer<typeof SearchServiceOutputSchema>;\n\nexport const searchServiceByKeywordTool = ai.defineTool(\n  {\n    name: 'searchServiceByKeywordTool',\n    description: 'Cari layanan berdasarkan keyword dari pelanggan dan (opsional) ukuran motor serta jenis cat. Berguna untuk menemukan layanan yang relevan beserta harganya.',\n    inputSchema: SearchServiceInputSchema,\n    outputSchema: SearchServiceOutputSchema,\n  },\n  async (input: SearchServiceInput): Promise<SearchServiceOutput> => {\n    if (!db) {\n      throw new Error(\"[searchServiceByKeywordTool.ts] FATAL: Client Firestore 'db' is not available at module load time. Firebase Client init failed or import order issue.\");\n    }\n\n    const { keyword, size, paintType } = input;\n    console.log(`[searchServiceByKeywordTool] Searching for keyword: \"${keyword}\", size: \"${size || 'any'}\", paintType: \"${paintType || 'any'}\"`);\n\n    const servicesCollectionRef = collection(db, 'services');\n    const snapshot = await getDocs(firestoreQuery(servicesCollectionRef));\n\n    const servicesFromDb: ServiceProduct[] = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as ServiceProduct));\n\n    if (servicesFromDb.length === 0) {\n      console.warn('[searchServiceByKeywordTool] No services found in the database.');\n      throw new Error('Tidak ada layanan yang terdaftar di database.');\n    }\n\n    const keywordLower = keyword.toLowerCase();\n    let bestMatch: ServiceProduct | undefined = undefined;\n    let highestScore = -1;\n\n    for (const svc of servicesFromDb) {\n      let currentScore = 0;\n      const nameLower = svc.name.toLowerCase();\n\n      if (nameLower.includes(keywordLower)) {\n        currentScore += 10;\n        if (nameLower === keywordLower) currentScore += 15;\n      }\n      if (svc.description?.toLowerCase().includes(keywordLower)) {\n        currentScore += 3;\n      }\n      if (svc.category?.toLowerCase().includes(keywordLower)) {\n        currentScore += 2;\n      }\n      if (svc.aliases && Array.isArray(svc.aliases)) {\n        if (svc.aliases.some(alias => alias.toLowerCase().includes(keywordLower))) {\n           currentScore += 8;\n           if (svc.aliases.some(alias => alias.toLowerCase() === keywordLower)) currentScore += 7;\n        }\n      }\n      if (svc.variants && svc.variants.length > 0) {\n        svc.variants.forEach(variant => {\n          if (variant.name.toLowerCase().includes(keywordLower)) {\n            currentScore += 5;\n          }\n        });\n      }\n\n      if (currentScore > highestScore) {\n        highestScore = currentScore;\n        bestMatch = svc;\n      }\n    }\n\n    if (!bestMatch || highestScore === 0) {\n      console.log(`[searchServiceByKeywordTool] No service found matching keyword: \"${keyword}\"`);\n      throw new Error(`Layanan tidak ditemukan untuk kata kunci \"${keyword}\".`);\n    }\n    console.log(`[searchServiceByKeywordTool] Best match found for keyword \"${keyword}\": ${bestMatch.name} with score ${highestScore}`);\n\n    let finalPrice: number | undefined = undefined;\n    let matchedVariantName: string | undefined = undefined;\n    let finalDuration = bestMatch.estimatedDuration || undefined;\n    let finalDescription = bestMatch.description || undefined;\n\n    if (bestMatch.variants && bestMatch.variants.length > 0) {\n      let suitableVariants = bestMatch.variants;\n\n      if (size) {\n        const sizeLower = size.toLowerCase();\n        const sizeRegex = new RegExp(`(?:\\\\bsize\\\\s+${sizeLower}\\\\b|\\\\b${sizeLower}\\\\b)`, 'i');\n        suitableVariants = suitableVariants.filter(v => sizeRegex.test(v.name));\n        console.log(`[searchServiceByKeywordTool] After size filter (\"${size}\"): ${suitableVariants.length} variants remaining for ${bestMatch.name}. Candidates: ${suitableVariants.map(v=>v.name).join(', ')}`);\n      }\n\n      if (paintType) {\n        const bestMatchNameLower = bestMatch.name.toLowerCase();\n        const paintTypeLower = paintType.toLowerCase();\n        // Only filter variants by paintType if bestMatch.name itself doesn't already clearly specify this paintType\n        if (!bestMatchNameLower.includes(paintTypeLower)) {\n          suitableVariants = suitableVariants.filter(v => v.name.toLowerCase().includes(paintTypeLower));\n          console.log(`[searchServiceByKeywordTool] After paintType filter (\"${paintType}\") for variants of \"${bestMatch.name}\": ${suitableVariants.length} variants remaining. Candidates: ${suitableVariants.map(v=>v.name).join(', ')}`);\n        } else {\n           console.log(`[searchServiceByKeywordTool] Skipping paintType filter on variants for \"${bestMatch.name}\" because base name already contains \"${paintType}\".`);\n        }\n      }\n\n      if (suitableVariants.length > 0) {\n        const variantToUse = suitableVariants[0];\n        finalPrice = variantToUse.price;\n        matchedVariantName = variantToUse.name;\n        finalDuration = variantToUse.estimatedDuration || finalDuration;\n      } else if (keyword.toLowerCase().includes(\"coating\") && (size || paintType)) {\n         console.log(`[searchServiceByKeywordTool] Coating query with size/paintType but no exact variant match for '${bestMatch.name}'. Price will be undefined.`);\n      } else if (bestMatch.variants.length > 0 && (!size && !paintType)) {\n        console.log(`[searchServiceByKeywordTool] Variants exist for '${bestMatch.name}', but no size/paintType provided. Price will be undefined.`);\n      }\n    } else {\n      finalPrice = bestMatch.price;\n    }\n\n    console.log(`[searchServiceByKeywordTool] Final price for \"${bestMatch.name}\" (Keyword: ${keyword}, Size: ${size || 'any'}, Paint: ${paintType || 'any'}, MatchedVariant: ${matchedVariantName || 'N/A'}): ${finalPrice === undefined ? 'Not Found/Specific' : finalPrice}`);\n\n    return {\n      name: bestMatch.name,\n      description: finalDescription,\n      price: finalPrice,\n      size: size,\n      duration: finalDuration,\n      variantMatched: matchedVariantName,\n    };\n  }\n);\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 589, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/tools/createBookingTool.ts"],"sourcesContent":["\n'use server';\n/**\n * @fileOverview Genkit tool for creating a booking entry.\n */\n\nimport { ai } from '@/ai/genkit';\nimport { z } from 'genkit';\nimport { db } from '@/lib/firebase';\nimport { collection, addDoc, doc, updateDoc, serverTimestamp, Timestamp } from 'firebase/firestore';\nimport type { BookingEntry, CreateBookingToolInput, CreateBookingToolOutput } from '@/types/booking';\nimport { isSameDay, parse as parseDateFns, setHours, setMinutes, startOfDay } from 'date-fns';\n\nconst CreateBookingInputSchema = z.object({\n  customerName: z.string().describe(\"Nama lengkap pelanggan.\"),\n  customerPhone: z.string().optional().describe(\"Nomor HP pelanggan (opsional).\"),\n  clientId: z.string().optional().describe(\"ID Klien jika pelanggan terdaftar (opsional).\"),\n  serviceId: z.string().describe(\"ID dari layanan/produk yang dibooking.\"),\n  serviceName: z.string().describe(\"Nama layanan/produk yang dibooking (bisa termasuk varian).\"),\n  vehicleInfo: z.string().describe(\"Informasi kendaraan pelanggan (mis. 'NMAX Merah', 'Vario 125 Hitam AB 1234 CD').\"),\n  bookingDate: z.string().regex(/^\\d{4}-\\d{2}-\\d{2}$/).describe(\"Tanggal booking dalam format YYYY-MM-DD.\"),\n  bookingTime: z.string().regex(/^\\d{2}:\\d{2}$/).describe(\"Waktu booking dalam format HH:MM (24 jam).\"),\n  estimatedDuration: z.string().optional().describe(\"Estimasi durasi layanan (mis. '30 mnt', '1 jam').\"),\n  notes: z.string().optional().describe(\"Catatan tambahan untuk booking (opsional).\"),\n});\n\nconst CreateBookingOutputSchema = z.object({\n  success: z.boolean().describe(\"Status keberhasilan pembuatan booking.\"),\n  bookingId: z.string().optional().describe(\"ID booking yang baru dibuat jika sukses.\"),\n  queueItemId: z.string().optional().describe(\"ID item antrian jika booking untuk hari ini dan berhasil ditambahkan ke antrian.\"),\n  message: z.string().describe(\"Pesan hasil operasi (mis. 'Booking berhasil dibuat.')\"),\n  status: z.string().optional().describe(\"Status booking yang dibuat.\"),\n});\n\nexport const createBookingTool = ai.defineTool(\n  {\n    name: 'createBookingTool',\n    description: 'Membuat entri booking baru di sistem. Jika booking untuk hari ini, otomatis tambahkan ke antrian.',\n    inputSchema: CreateBookingInputSchema,\n    outputSchema: CreateBookingOutputSchema,\n  },\n  async (input: CreateBookingToolInput): Promise<CreateBookingToolOutput> => {\n    if (!db) {\n      throw new Error(\"[createBookingTool.ts] FATAL: Client Firestore 'db' is not available. Firebase Client init failed.\");\n    }\n    console.log('[createBookingTool] Input received:', input);\n\n    try {\n      const { bookingDate, bookingTime, ...restOfInput } = input;\n      \n      let parsedBookingDate: Date;\n      try {\n        parsedBookingDate = parseDateFns(bookingDate, 'yyyy-MM-dd', new Date());\n      } catch (e) {\n        console.error('[createBookingTool] Invalid bookingDate format:', bookingDate);\n        return { success: false, message: `Format tanggal booking (${bookingDate}) tidak valid. Gunakan YYYY-MM-DD.` };\n      }\n\n      const [hourStr, minuteStr] = bookingTime.split(':');\n      const hour = parseInt(hourStr, 10);\n      const minute = parseInt(minuteStr, 10);\n\n      if (isNaN(hour) || isNaN(minute) || hour < 0 || hour > 23 || minute < 0 || minute > 59) {\n        console.error('[createBookingTool] Invalid bookingTime format:', bookingTime);\n        return { success: false, message: `Format waktu booking (${bookingTime}) tidak valid. Gunakan HH:MM.` };\n      }\n\n      const bookingDateTimeWithClientTimezone = setMinutes(setHours(parsedBookingDate, hour), minute);\n      const bookingTimestamp = Timestamp.fromDate(bookingDateTimeWithClientTimezone);\n\n      const newBookingData: Omit<BookingEntry, 'id' | 'createdAt' | 'updatedAt' | 'queueItemId'> = {\n        ...restOfInput,\n        bookingDateTime: bookingTimestamp,\n        status: 'Confirmed', // Default status\n        source: 'WhatsApp', // Default source for AI bookings\n        createdAt: serverTimestamp() as Timestamp,\n        updatedAt: serverTimestamp() as Timestamp,\n      };\n\n      const bookingDocRef = await addDoc(collection(db, 'bookings'), newBookingData);\n      console.log('[createBookingTool] Booking successfully created with ID:', bookingDocRef.id);\n\n      let queueItemId: string | undefined = undefined;\n      let message = `Booking untuk ${input.customerName} tanggal ${bookingDate} jam ${bookingTime} untuk layanan \"${input.serviceName}\" berhasil dicatat.`;\n\n      // Jika booking untuk hari ini, tambahkan ke antrian\n      if (isSameDay(bookingDateTimeWithClientTimezone, new Date())) {\n        const queueItemData = {\n          customerName: input.customerName,\n          clientId: input.clientId,\n          vehicleInfo: input.vehicleInfo,\n          service: input.serviceName,\n          serviceId: input.serviceId,\n          // variantId: input.variantId, // Assuming variant info is part of serviceName for booking\n          status: 'Menunggu' as 'Menunggu',\n          estimatedTime: input.estimatedDuration || 'N/A',\n          bookingId: bookingDocRef.id,\n          createdAt: bookingTimestamp, // Gunakan waktu booking untuk createdAt antrian\n        };\n        const queueDocRef = await addDoc(collection(db, 'queueItems'), queueItemData);\n        queueItemId = queueDocRef.id;\n        await updateDoc(bookingDocRef, { queueItemId: queueItemId, status: 'In Queue' });\n        message += \" Karena booking untuk hari ini, pelanggan juga sudah otomatis ditambahkan ke antrian.\";\n        console.log('[createBookingTool] Booking for today, added to queue with ID:', queueItemId);\n      }\n\n      return {\n        success: true,\n        bookingId: bookingDocRef.id,\n        queueItemId: queueItemId,\n        message: message,\n        status: queueItemId ? 'In Queue' : 'Confirmed',\n      };\n\n    } catch (error: any) {\n      console.error('[createBookingTool] Error creating booking:', error);\n      return {\n        success: false,\n        message: `Gagal membuat booking: ${error.message || 'Terjadi kesalahan tidak diketahui.'}`,\n      };\n    }\n  }\n);\n"],"names":[],"mappings":";;;;;AAEA;;CAEC,GAED;AACA;AAAA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;;;;;;AAEA,MAAM,2BAA2B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACxC,cAAc,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAClC,eAAe,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;IAC9C,UAAU,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;IACzC,WAAW,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC/B,aAAa,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACjC,aAAa,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACjC,aAAa,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,KAAK,CAAC,uBAAuB,QAAQ,CAAC;IAC9D,aAAa,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,KAAK,CAAC,iBAAiB,QAAQ,CAAC;IACxD,mBAAmB,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;IAClD,OAAO,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;AACxC;AAEA,MAAM,4BAA4B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACzC,SAAS,uIAAA,CAAA,IAAC,CAAC,OAAO,GAAG,QAAQ,CAAC;IAC9B,WAAW,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;IAC1C,aAAa,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;IAC5C,SAAS,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC7B,QAAQ,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;AACzC;AAEO,MAAM,oBAAoB,mHAAA,CAAA,KAAE,CAAC,UAAU,CAC5C;IACE,MAAM;IACN,aAAa;IACb,aAAa;IACb,cAAc;AAChB,GACA,OAAO;IACL,IAAI,CAAC,sHAAA,CAAA,KAAE,EAAE;QACP,MAAM,IAAI,MAAM;IAClB;IACA,QAAQ,GAAG,CAAC,uCAAuC;IAEnD,IAAI;QACF,MAAM,EAAE,WAAW,EAAE,WAAW,EAAE,GAAG,aAAa,GAAG;QAErD,IAAI;QACJ,IAAI;YACF,oBAAoB,CAAA,GAAA,qJAAA,CAAA,QAAY,AAAD,EAAE,aAAa,cAAc,IAAI;QAClE,EAAE,OAAO,GAAG;YACV,QAAQ,KAAK,CAAC,mDAAmD;YACjE,OAAO;gBAAE,SAAS;gBAAO,SAAS,CAAC,wBAAwB,EAAE,YAAY,kCAAkC,CAAC;YAAC;QAC/G;QAEA,MAAM,CAAC,SAAS,UAAU,GAAG,YAAY,KAAK,CAAC;QAC/C,MAAM,OAAO,SAAS,SAAS;QAC/B,MAAM,SAAS,SAAS,WAAW;QAEnC,IAAI,MAAM,SAAS,MAAM,WAAW,OAAO,KAAK,OAAO,MAAM,SAAS,KAAK,SAAS,IAAI;YACtF,QAAQ,KAAK,CAAC,mDAAmD;YACjE,OAAO;gBAAE,SAAS;gBAAO,SAAS,CAAC,sBAAsB,EAAE,YAAY,6BAA6B,CAAC;YAAC;QACxG;QAEA,MAAM,oCAAoC,CAAA,GAAA,0IAAA,CAAA,aAAU,AAAD,EAAE,CAAA,GAAA,wIAAA,CAAA,WAAQ,AAAD,EAAE,mBAAmB,OAAO;QACxF,MAAM,mBAAmB,iKAAA,CAAA,YAAS,CAAC,QAAQ,CAAC;QAE5C,MAAM,iBAAuF;YAC3F,GAAG,WAAW;YACd,iBAAiB;YACjB,QAAQ;YACR,QAAQ;YACR,WAAW,CAAA,GAAA,iKAAA,CAAA,kBAAe,AAAD;YACzB,WAAW,CAAA,GAAA,iKAAA,CAAA,kBAAe,AAAD;QAC3B;QAEA,MAAM,gBAAgB,MAAM,CAAA,GAAA,iKAAA,CAAA,SAAM,AAAD,EAAE,CAAA,GAAA,iKAAA,CAAA,aAAU,AAAD,EAAE,sHAAA,CAAA,KAAE,EAAE,aAAa;QAC/D,QAAQ,GAAG,CAAC,6DAA6D,cAAc,EAAE;QAEzF,IAAI,cAAkC;QACtC,IAAI,UAAU,CAAC,cAAc,EAAE,MAAM,YAAY,CAAC,SAAS,EAAE,YAAY,KAAK,EAAE,YAAY,gBAAgB,EAAE,MAAM,WAAW,CAAC,mBAAmB,CAAC;QAEpJ,oDAAoD;QACpD,IAAI,CAAA,GAAA,yIAAA,CAAA,YAAS,AAAD,EAAE,mCAAmC,IAAI,SAAS;YAC5D,MAAM,gBAAgB;gBACpB,cAAc,MAAM,YAAY;gBAChC,UAAU,MAAM,QAAQ;gBACxB,aAAa,MAAM,WAAW;gBAC9B,SAAS,MAAM,WAAW;gBAC1B,WAAW,MAAM,SAAS;gBAC1B,0FAA0F;gBAC1F,QAAQ;gBACR,eAAe,MAAM,iBAAiB,IAAI;gBAC1C,WAAW,cAAc,EAAE;gBAC3B,WAAW;YACb;YACA,MAAM,cAAc,MAAM,CAAA,GAAA,iKAAA,CAAA,SAAM,AAAD,EAAE,CAAA,GAAA,iKAAA,CAAA,aAAU,AAAD,EAAE,sHAAA,CAAA,KAAE,EAAE,eAAe;YAC/D,cAAc,YAAY,EAAE;YAC5B,MAAM,CAAA,GAAA,iKAAA,CAAA,YAAS,AAAD,EAAE,eAAe;gBAAE,aAAa;gBAAa,QAAQ;YAAW;YAC9E,WAAW;YACX,QAAQ,GAAG,CAAC,kEAAkE;QAChF;QAEA,OAAO;YACL,SAAS;YACT,WAAW,cAAc,EAAE;YAC3B,aAAa;YACb,SAAS;YACT,QAAQ,cAAc,aAAa;QACrC;IAEF,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,+CAA+C;QAC7D,OAAO;YACL,SAAS;YACT,SAAS,CAAC,uBAAuB,EAAE,MAAM,OAAO,IAAI,sCAAsC;QAC5F;IACF;AACF;;;IAvFW;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 728, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/types/ai/cs-whatsapp-reply.ts"],"sourcesContent":["\nimport { z } from 'genkit';\n\nexport const ChatMessageSchema = z.object({\n  role: z.enum(['user', 'model']), // 'user' for customer/CS agent, 'model' for AI's previous replies\n  content: z.string(),\n});\nexport type ChatMessage = z.infer<typeof ChatMessageSchema>;\n\nexport const WhatsAppReplyInputSchema = z.object({\n  customerMessage: z.string().describe('Pesan yang diterima dari pelanggan melalui WhatsApp, atau pertanyaan dari staf CS.'),\n  senderNumber: z.string().optional().describe('Nomor WhatsApp pengirim pesan (pelanggan).'),\n  chatHistory: z.array(ChatMessageSchema).optional().describe('Riwayat percakapan sebelumnya antara pelanggan dan AI/staf CS.'),\n  agentBehavior: z.string().optional().describe('Perilaku agen AI yang diinginkan, mis. \"Ramah & Membantu\".'),\n  knowledgeBase: z.string().optional().describe('Panduan tingkat tinggi untuk AI. Detail pengetahuan spesifik akan diambil melalui tools.'),\n  currentDate: z.string().optional().describe('Tanggal saat ini dalam format YYYY-MM-DD. Berguna untuk konteks booking.'),\n  currentTime: z.string().optional().describe('Waktu saat ini dalam format HH:MM (24 jam). Berguna untuk konteks booking.'),\n  tomorrowDate: z.string().optional().describe('Tanggal besok dalam format YYYY-MM-DD. Berguna untuk konteks booking.'),\n  dayAfterTomorrowDate: z.string().optional().describe('Tanggal lusa (besoknya besok) dalam format YYYY-MM-DD. Berguna untuk konteks booking.'),\n});\nexport type WhatsAppReplyInput = z.infer<typeof WhatsAppReplyInputSchema>;\n\nexport const WhatsAppReplyOutputSchema = z.object({\n  suggestedReply: z.string().describe('Saran balasan yang dihasilkan AI untuk dikirim ke pelanggan.'),\n});\nexport type WhatsAppReplyOutput = z.infer<typeof WhatsAppReplyOutputSchema>;\n    \n"],"names":[],"mappings":";;;;;AACA;AAAA;;AAEO,MAAM,oBAAoB,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACxC,MAAM,uIAAA,CAAA,IAAC,CAAC,IAAI,CAAC;QAAC;QAAQ;KAAQ;IAC9B,SAAS,uIAAA,CAAA,IAAC,CAAC,MAAM;AACnB;AAGO,MAAM,2BAA2B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC/C,iBAAiB,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACrC,cAAc,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;IAC7C,aAAa,uIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,mBAAmB,QAAQ,GAAG,QAAQ,CAAC;IAC5D,eAAe,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;IAC9C,eAAe,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;IAC9C,aAAa,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;IAC5C,aAAa,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;IAC5C,cAAc,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;IAC7C,sBAAsB,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;AACvD;AAGO,MAAM,4BAA4B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAChD,gBAAgB,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AACtC","debugId":null}},
    {"offset": {"line": 763, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/cs-whatsapp-reply-flow.ts"],"sourcesContent":["\n'use server';\n/**\n * @fileOverview AI flow for WhatsApp customer service replies.\n * - whatsAppReplyFlowSimplified - Main flow for generating WhatsApp replies.\n */\n\nimport { ai } from '@/ai/genkit';\nimport { z } from 'genkit'; // Menggunakan z dari genkit\nimport { extractMotorInfoTool } from '@/ai/tools/extractMotorInfoTool';\nimport { searchServiceByKeywordTool } from '@/ai/tools/searchServiceByKeywordTool';\nimport { createBookingTool } from '@/ai/tools/createBookingTool'; // Import tool booking\nimport type { WhatsAppReplyInput, WhatsAppReplyOutput, ChatMessage } from '@/types/ai/cs-whatsapp-reply';\nimport { WhatsAppReplyInputSchema, WhatsAppReplyOutputSchema } from '@/types/ai/cs-whatsapp-reply';\n\n// Prompt Zoya yang diperbarui\nconst promptZoya = `\nAnda adalah Zoya, Customer Service AI dari QLAB Moto Detailing.\n\nGaya bahasa:\n- Santai dan akrab, pakai sapaan seperti \"bro\", \"kak\", \"mas\".\n- Tetap informatif dan jelas.\n\nTool yang tersedia:\n1.  'extractMotorInfoTool': Untuk mendeteksi merek, model, dan ukuran motor dari teks. Input: {\"text\": \"deskripsi motor\"}. Output: {\"brand\": \"...\", \"model\": \"...\", \"size\": \"S/M/L/XL\"}\n2.  'searchServiceByKeywordTool': Untuk mencari detail layanan/produk. Input: {\"keyword\": \"nama layanan/produk\", \"size\": \"S/M/L/XL\" (opsional), \"paintType\": \"doff\" atau \"glossy\" (opsional, penting untuk coating)}. Output: {\"name\": \"...\", \"description\": \"...\", \"price\": ..., \"duration\": \"...\", \"variantMatched\": \"...\"}\n3.  'createBookingTool': Untuk mencatat booking pelanggan. Input: {\"customerName\": \"...\", \"customerPhone\": \"...\", \"clientId\": \"...\", \"serviceId\": \"...\", \"serviceName\": \"...\", \"vehicleInfo\": \"...\", \"bookingDate\": \"YYYY-MM-DD\", \"bookingTime\": \"HH:MM\", \"estimatedDuration\": \"...\", \"notes\": \"...\"}. Output: {\"success\": true/false, \"bookingId\": \"...\", \"queueItemId\": \"...\", \"message\": \"...\", \"status\": \"...\"}\n\nTugas kamu:\n1.  Pahami permintaan pelanggan. Identifikasi apakah mereka bertanya tentang layanan/produk, ingin booking, atau hal lain.\n\n2.  **Jika pelanggan bertanya tentang layanan/produk SPESIFIK (misalnya \"coating\", \"cuci motor\", \"harga nmax coating\", \"info detailing\"):**\n    a.  **Deteksi Motor Dulu (Jika Ada):** Jika pelanggan menyebutkan jenis motor (misalnya \"NMAX\", \"Vario\", \"Beat\"), gunakan 'extractMotorInfoTool' untuk mendapatkan 'brand', 'model', dan 'size' motornya.\n        Contoh: Jika pelanggan bilang \"coating NMAX berapa?\", panggil 'extractMotorInfoTool' dengan input \\`{\"text\": \"NMAX\"}\\`.\n    b.  **Logika Khusus untuk \"COATING\":**\n        *   Jika kata kunci pertanyaan mengandung \"coating\" (atau sinonimnya seperti \"laminating\", \"ceramic coating\"):\n            *   Jika 'brand', 'model', atau 'size' motor SUDAH diketahui (dari langkah 2a atau pesan pelanggan), TAPI jenis cat (\"doff\" atau \"glossy\") BELUM disebutkan oleh pelanggan:\n                *   **JANGAN LANGSUNG CARI HARGA.** Balas dengan pertanyaan: \"Oke bro, untuk coating motor (sebutkan model motor jika tahu), jenis catnya doff atau glossy ya? Biar harganya pas.\"\n                *   Tunggu jawaban pelanggan berikutnya untuk jenis cat.\n            *   Jika 'brand', 'model', atau 'size' motor SUDAH diketahui DAN jenis cat (\"doff\" atau \"glossy\") JUGA SUDAH disebutkan:\n                *   Panggil 'searchServiceByKeywordTool' dengan 'keyword: \"coating\"', 'size' yang relevan, DAN 'paintType' (\"doff\" atau \"glossy\").\n                *   Lanjutkan ke langkah 2.d untuk memformulasikan jawaban berdasarkan output tool.\n            *   Jika kata kunci \"coating\" disebut tapi motor BELUM disebutkan:\n                *   Panggil 'searchServiceByKeywordTool' HANYA dengan 'keyword: \"coating\"' (tanpa size, tanpa paintType).\n                *   Gunakan 'description' dari output tool untuk menjelaskan layanan coating secara umum.\n                *   Kemudian, tanyakan motornya DAN jenis catnya sekaligus. Contoh: \"Coating itu (ambil dari deskripsi tool). Nah, buat motor apa nih bro? Sama jenis catnya doff atau glossy sekalian ya, biar Zoya bisa kasih info harga yang pas.\"\n    c.  **Untuk Layanan/Produk LAIN SELAIN COATING (atau jika info coating sudah lengkap dan tool 'searchServiceByKeywordTool' akan dipanggil):**\n        *   Gunakan 'searchServiceByKeywordTool'. 'keyword'-nya adalah nama layanan/produk yang ditanyakan (mis. \"cuci motor\", \"detailing\").\n        *   Jika kamu berhasil mendapatkan 'size' motor dari langkah 2a (atau dari info sebelumnya), sertakan 'size' tersebut saat memanggil 'searchServiceByKeywordTool'.\n        *   Jika pelanggan TIDAK menyebutkan motor, panggil 'searchServiceByKeywordTool' HANYA dengan 'keyword' (tanpa 'size').\n        *   Lanjutkan ke langkah 2.d untuk memformulasikan jawaban.\n    d.  **Formulasikan Jawaban (setelah memanggil 'searchServiceByKeywordTool'):**\n        *   **Kasus 1: Tool dipanggil TANPA size (karena motor belum diketahui).**\n            *   Jika tool mengembalikan hasil (ada 'name', 'description'), jelaskan layanannya (gunakan 'description' dari output tool). Lalu, TANYAKAN jenis motor pelanggan. Contoh: \"Detailing itu (deskripsi dari tool). Nah, buat motor apa nih bro? Biar Zoya bisa kasih info harga yang pas.\"\n            *   Jika tool TIDAK menemukan info layanan sama sekali, jawab sopan bahwa kamu belum nemu info detailnya dan tetap tanyakan motornya apa.\n        *   **Kasus 2: Tool dipanggil DENGAN size (motor sudah diketahui, DAN jika COATING, jenis cat juga SUDAH diketahui).**\n            *   **Periksa output dari 'searchServiceByKeywordTool' dengan SANGAT SEKSAMA:**\n                *   **JIKA ADA field 'price' di output tool DAN 'price' LEBIH DARI 0:** Sebutkan 'name' (dari tool, mungkin dengan 'variantMatched' jika ada), 'price' (dari tool), dan 'duration' (estimasi durasi dari tool, jika ada).\n                    Contoh: \"Oke bro, untuk NMAX Doff coatingnya Rp XXX (harga dari searchService), pengerjaannya sekitar YYY (durasi dari searchService). Minat sekalian booking?\" (Gunakan nama motor dan varian yang sesuai).\n                *   **JIKA TIDAK ADA field 'price' di output tool (artinya 'price' adalah undefined), ATAU 'price' adalah 0 (dan kamu TIDAK punya info eksplisit bahwa layanan/produk tersebut memang gratis):**\n                    *   **SANGAT PENTING: JANGAN bilang \"sebentar aku cek\", \"aku lagi cari\", atau variasi serupa yang mengindikasikan kamu masih mencari harga.** Kamu sudah selesai mencari.\n                    *   **LANGSUNG informasikan bahwa harga spesifik untuk kombinasi motor dan layanan itu belum ketemu.**\n                    *   Jika ada 'description' dan 'name' dari tool, kamu bisa sampaikan deskripsinya dulu. Contoh: \"Untuk (nama layanan dari tool, mis. Coating NMAX Doff), deskripsinya (deskripsi dari tool). Nah, untuk harga pastinya Zoya belum ada info nih bro.\"\n                    *   Kemudian, kamu bisa tawarkan bantuan lain atau arahkan. Contoh: \"Mungkin bisa coba pastiin lagi tipe NMAX-nya atau jenis coating doff yang lebih detail? Atau mau Zoya bantu tanyain ke CS langsung di [nomor CS WA CS Manusia jika ada]?\"\n                    *   **JANGAN mengarang harga atau memberi placeholder harga seperti '[harga]'.**\n\n3.  **Jika pelanggan mau booking (setelah dapat info harga atau langsung minta booking):**\n    a.  **Periksa Info yang Sudah Ada**: Cek apakah kamu sudah tahu dari percakapan atau tool sebelumnya:\n        *   Nama Pelanggan? (Bisa dari 'senderName' jika terhubung ke WhatsApp atau dari chat)\n        *   No HP Pelanggan? (Bisa dari 'senderNumber' jika terhubung ke WhatsApp atau dari chat)\n        *   Layanan yang diinginkan? (Harus ada 'serviceId' dan 'serviceName' dari hasil 'searchServiceByKeywordTool' sebelumnya)\n        *   Jenis Motor? (Dari 'extractMotorInfoTool' atau konfirmasi pelanggan)\n        *   Tanggal Booking? (Format YYYY-MM-DD)\n        *   Jam Booking? (Format HH:MM)\n    b.  **Jika Banyak Info Kurang**: Balas dengan: 'Oke bro, untuk bookingnya, Zoya butuh info ini ya:\\\\nNama :\\\\nNo HP :\\\\nLayanan yang di inginkan :\\\\nTanggal :\\\\nJam kedatangan :\\\\nJenis Motor :'\n    c.  **Jika Hanya Beberapa Info Kurang**: Tanyakan yang kurang saja secara spesifik. Contoh: 'Siap bro! Untuk layanan [Layanan yang sudah diketahui], mau booking tanggal dan jam berapa? Nama dan No HPnya juga ya kalau belum ada.'\n    d.  **Jika Semua Info Sudah Lengkap**: Panggil tool 'createBookingTool' dengan semua data yang telah terkumpul.\n        *   'serviceId' dan 'serviceName' ambil dari hasil pencarian layanan sebelumnya.\n        *   'vehicleInfo' gabungkan informasi motor (mis. \"NMAX Merah Doff\").\n        *   'customerPhone' dan 'clientId' itu opsional untuk tool, tapi bagus kalau ada dan bisa diisi dari 'senderNumber' atau info klien yang sudah ada.\n        *   'estimatedDuration' bisa diambil dari hasil pencarian layanan jika ada.\n    e.  **Sampaikan Hasil**: Berdasarkan output dari 'createBookingTool':\n        *   Jika 'success: true', sampaikan pesan sukses dari tool. Contoh: 'Sip bro! Booking kamu udah dicatet. Ini detailnya: [message dari tool].'\n        *   Jika 'success: false', sampaikan pesan error dari tool. Contoh: 'Waduh, maaf bro, ada kendala nih: [message dari tool]. Coba lagi atau hubungi CS ya.'\n\n4.  **Umum:**\n    *   Jika tidak yakin atau permintaan di luar kemampuanmu, arahkan pelanggan ke CS manusia.\n    *   Selalu gunakan sapaan akrab.\n\nFormat output HARUS berupa JSON:\n{ \"suggestedReply\": \"Teks balasan disini\" }\n\nChat customer terbaru:\nuser: {{{customerMessage}}}\n\nRiwayat sebelumnya:\n{{#if chatHistory.length}}\n{{#each chatHistory}}\n{{this.role}}: {{this.content}}\n{{/each}}\n{{/if}}\n\nTanggal hari ini: {{{currentDate}}}, waktu: {{{currentTime}}}\nBesok: {{{tomorrowDate}}}, Lusa: {{{dayAfterTomorrowDate}}}\n`;\n\n\n/**\n * Define prompt untuk Zoya dengan tool yang diperlukan\n */\nconst replyPromptSimplified = ai.definePrompt({\n  name: 'whatsAppReplyPromptSimplified',\n  input: { schema: WhatsAppReplyInputSchema },\n  output: { schema: WhatsAppReplyOutputSchema },\n  tools: [extractMotorInfoTool, searchServiceByKeywordTool, createBookingTool], // Tambahkan createBookingTool\n  prompt: promptZoya,\n});\n\n/**\n * Flow utama untuk digunakan di API/function/genkit handler\n */\nexport const whatsAppReplyFlowSimplified = ai.defineFlow(\n  {\n    name: 'whatsAppReplyFlowSimplified',\n    inputSchema: WhatsAppReplyInputSchema,\n    outputSchema: WhatsAppReplyOutputSchema,\n  },\n  async (input: WhatsAppReplyInput): Promise<WhatsAppReplyOutput> => {\n    try { // Outer try block for the entire flow logic\n      console.log(\"[CS-FLOW] whatsAppReplyFlowSimplified input:\", JSON.stringify(input, null, 2));\n      try { // Inner try block specifically for the AI call and its direct output processing\n        const { output } = await replyPromptSimplified(input);\n        if (!output || !output.suggestedReply) { \n          console.error('[CS-FLOW] ❌ Gagal mendapatkan balasan dari AI atau output tidak sesuai skema (output atau suggestedReply null/undefined). Mengembalikan default.');\n          return { suggestedReply: \"Maaf, Zoya lagi bingung nih. Bisa diulang pertanyaannya atau coba beberapa saat lagi?\" };\n        }\n        console.log(\"[CS-FLOW] whatsAppReplyFlowSimplified output dari prompt:\", output);\n        return output;\n      } catch (aiError: any) { // Catch errors specifically from the AI prompt/tool execution\n        console.error('[CS-FLOW] ❌ Error saat menjalankan prompt AI atau memproses outputnya:', aiError);\n        let finalErrorMessage = \"Maaf, ada sedikit gangguan teknis di sistem Zoya.\";\n        // Simplified error message to avoid complex string manipulation issues\n        if (aiError instanceof Error && aiError.message) {\n            finalErrorMessage = `Duh, Zoya lagi ada kendala nih: ${aiError.message.substring(0, 80)}... Coba lagi ya.`;\n        } else if (typeof aiError === 'string') {\n            finalErrorMessage = `Duh, Zoya lagi ada kendala: ${aiError.substring(0, 80)}... Coba lagi ya.`;\n        }\n        return { suggestedReply: finalErrorMessage };\n      }\n    } catch (flowError: any) { // Catch any other errors within the flow (e.g., JSON.stringify, unexpected issues)\n        console.error('[CS-FLOW] ❌ Critical error dalam flow whatsAppReplyFlowSimplified:', flowError);\n        // Return a generic, safe, valid JSON response\n        return { suggestedReply: \"Waduh, sistem Zoya lagi ada kendala besar nih. Mohon coba beberapa saat lagi ya.\" };\n    }\n  }\n);\n\nexport async function generateWhatsAppReply(input: WhatsAppReplyInput): Promise<WhatsAppReplyOutput> {\n  // Memastikan semua properti opsional yang dibutuhkan oleh prompt ada, meskipun undefined\n  const flowInput: WhatsAppReplyInput = {\n    customerMessage: input.customerMessage,\n    senderNumber: input.senderNumber, // Boleh undefined jika tidak ada\n    chatHistory: input.chatHistory || [],\n    // Pastikan nilai default atau dari input ada untuk variabel tanggal/waktu\n    currentDate: input.currentDate || new Date().toLocaleDateString('id-ID', { year: 'numeric', month: '2-digit', day: '2-digit' }),\n    currentTime: input.currentTime || new Date().toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit', hour12: false }),\n    tomorrowDate: input.tomorrowDate || new Date(Date.now() + 86400000).toLocaleDateString('id-ID', { year: 'numeric', month: '2-digit', day: '2-digit' }),\n    dayAfterTomorrowDate: input.dayAfterTomorrowDate || new Date(Date.now() + 2 * 86400000).toLocaleDateString('id-ID', { year: 'numeric', month: '2-digit', day: '2-digit' }),\n    agentBehavior: input.agentBehavior, // Boleh undefined\n    knowledgeBase: input.knowledgeBase, // Boleh undefined\n  };\n  return whatsAppReplyFlowSimplified(flowInput);\n}\n\n"],"names":[],"mappings":";;;;;;AAEA;;;CAGC,GAED;AAEA;AACA;AACA,6OAAkE,sBAAsB;AAExF;;;;;;;;;AAEA,8BAA8B;AAC9B,MAAM,aAAa,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwFpB,CAAC;AAGD;;CAEC,GACD,MAAM,wBAAwB,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC5C,MAAM;IACN,OAAO;QAAE,QAAQ,6IAAA,CAAA,2BAAwB;IAAC;IAC1C,QAAQ;QAAE,QAAQ,6IAAA,CAAA,4BAAyB;IAAC;IAC5C,OAAO;QAAC,0IAAA,CAAA,uBAAoB;QAAE,gJAAA,CAAA,6BAA0B;QAAE,uIAAA,CAAA,oBAAiB;KAAC;IAC5E,QAAQ;AACV;AAKO,MAAM,8BAA8B,mHAAA,CAAA,KAAE,CAAC,UAAU,CACtD;IACE,MAAM;IACN,aAAa,6IAAA,CAAA,2BAAwB;IACrC,cAAc,6IAAA,CAAA,4BAAyB;AACzC,GACA,OAAO;IACL,IAAI;QACF,QAAQ,GAAG,CAAC,gDAAgD,KAAK,SAAS,CAAC,OAAO,MAAM;QACxF,IAAI;YACF,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,sBAAsB;YAC/C,IAAI,CAAC,UAAU,CAAC,OAAO,cAAc,EAAE;gBACrC,QAAQ,KAAK,CAAC;gBACd,OAAO;oBAAE,gBAAgB;gBAAwF;YACnH;YACA,QAAQ,GAAG,CAAC,6DAA6D;YACzE,OAAO;QACT,EAAE,OAAO,SAAc;YACrB,QAAQ,KAAK,CAAC,0EAA0E;YACxF,IAAI,oBAAoB;YACxB,uEAAuE;YACvE,IAAI,mBAAmB,SAAS,QAAQ,OAAO,EAAE;gBAC7C,oBAAoB,CAAC,gCAAgC,EAAE,QAAQ,OAAO,CAAC,SAAS,CAAC,GAAG,IAAI,iBAAiB,CAAC;YAC9G,OAAO,IAAI,OAAO,YAAY,UAAU;gBACpC,oBAAoB,CAAC,4BAA4B,EAAE,QAAQ,SAAS,CAAC,GAAG,IAAI,iBAAiB,CAAC;YAClG;YACA,OAAO;gBAAE,gBAAgB;YAAkB;QAC7C;IACF,EAAE,OAAO,WAAgB;QACrB,QAAQ,KAAK,CAAC,sEAAsE;QACpF,8CAA8C;QAC9C,OAAO;YAAE,gBAAgB;QAAmF;IAChH;AACF;AAGK,eAAe,sBAAsB,KAAyB;IACnE,yFAAyF;IACzF,MAAM,YAAgC;QACpC,iBAAiB,MAAM,eAAe;QACtC,cAAc,MAAM,YAAY;QAChC,aAAa,MAAM,WAAW,IAAI,EAAE;QACpC,0EAA0E;QAC1E,aAAa,MAAM,WAAW,IAAI,IAAI,OAAO,kBAAkB,CAAC,SAAS;YAAE,MAAM;YAAW,OAAO;YAAW,KAAK;QAAU;QAC7H,aAAa,MAAM,WAAW,IAAI,IAAI,OAAO,kBAAkB,CAAC,SAAS;YAAE,MAAM;YAAW,QAAQ;YAAW,QAAQ;QAAM;QAC7H,cAAc,MAAM,YAAY,IAAI,IAAI,KAAK,KAAK,GAAG,KAAK,UAAU,kBAAkB,CAAC,SAAS;YAAE,MAAM;YAAW,OAAO;YAAW,KAAK;QAAU;QACpJ,sBAAsB,MAAM,oBAAoB,IAAI,IAAI,KAAK,KAAK,GAAG,KAAK,IAAI,UAAU,kBAAkB,CAAC,SAAS;YAAE,MAAM;YAAW,OAAO;YAAW,KAAK;QAAU;QACxK,eAAe,MAAM,aAAa;QAClC,eAAe,MAAM,aAAa;IACpC;IACA,OAAO,4BAA4B;AACrC;;;IAnDa;IAoCS;;AApCT,+OAAA;AAoCS,+OAAA","debugId":null}},
    {"offset": {"line": 975, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/.next-internal/server/app/%28app%29/ai-cs-assistant/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {generateWhatsAppReply as '4053660f6447b38038e1d20965a3df3cd57a2a7b51'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA","debugId":null}},
    {"offset": {"line": 1039, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/%28app%29/ai-cs-assistant/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/(app)/ai-cs-assistant/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/(app)/ai-cs-assistant/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAA0S,GACvU,wEACA","debugId":null}},
    {"offset": {"line": 1053, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/%28app%29/ai-cs-assistant/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/(app)/ai-cs-assistant/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/(app)/ai-cs-assistant/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAsR,GACnT,oDACA","debugId":null}},
    {"offset": {"line": 1067, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}