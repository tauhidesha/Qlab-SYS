{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 111, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/firebase.ts"],"sourcesContent":["\nimport { initializeApp, getApp, getApps, type FirebaseApp } from \"firebase/app\";\nimport { getFirestore, type Firestore } from \"firebase/firestore\";\n\n// Minimal logging\nconsole.log(\"[firebase.ts] Initializing Firebase...\");\n\nconst firebaseConfig = {\n  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,\n  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,\n  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,\n  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,\n  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,\n  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,\n};\n\nif (!firebaseConfig.projectId || !firebaseConfig.apiKey) {\n  console.error(\"[firebase.ts] FATAL ERROR: Firebase projectId or apiKey is MISSING in environment variables.\");\n}\n\nlet app: FirebaseApp;\nlet db: Firestore;\n\nif (getApps().length === 0) {\n  try {\n    app = initializeApp(firebaseConfig);\n    console.log(\"[firebase.ts] Firebase app initialized. Project ID:\", app.options.projectId);\n  } catch (e: any) {\n    console.error(\"[firebase.ts] FAILED to initialize Firebase app:\", e.message);\n    // @ts-ignore\n    app = null;\n  }\n} else {\n  app = getApp();\n  console.log(\"[firebase.ts] Using existing Firebase app. Project ID:\", app.options.projectId);\n}\n\n// @ts-ignore\nif (app) {\n  try {\n    // @ts-ignore\n    db = getFirestore(app);\n    console.log(\"[firebase.ts] Firestore instance obtained.\");\n  } catch (e: any) {\n    console.error(\"[firebase.ts] FAILED to get Firestore instance:\", e?.message);\n  }\n} else {\n    console.error(\"[firebase.ts] Firebase app not properly initialized, cannot get Firestore.\");\n}\n\nexport { app, db };\n"],"names":[],"mappings":";;;;AACA;AAAA;AACA;AAAA;;;AAEA,kBAAkB;AAClB,QAAQ,GAAG,CAAC;AAEZ,MAAM,iBAAiB;IACrB,MAAM;IACN,UAAU;IACV,SAAS;IACT,aAAa;IACb,iBAAiB;IACjB,KAAK;AACP;AAEA,IAAI,CAAC,eAAe,SAAS,IAAI,CAAC,eAAe,MAAM,EAAE;IACvD,QAAQ,KAAK,CAAC;AAChB;AAEA,IAAI;AACJ,IAAI;AAEJ,IAAI,CAAA,GAAA,oLAAA,CAAA,UAAO,AAAD,IAAI,MAAM,KAAK,GAAG;IAC1B,IAAI;QACF,MAAM,CAAA,GAAA,oLAAA,CAAA,gBAAa,AAAD,EAAE;QACpB,QAAQ,GAAG,CAAC,uDAAuD,IAAI,OAAO,CAAC,SAAS;IAC1F,EAAE,OAAO,GAAQ;QACf,QAAQ,KAAK,CAAC,oDAAoD,EAAE,OAAO;QAC3E,aAAa;QACb,MAAM;IACR;AACF,OAAO;IACL,MAAM,CAAA,GAAA,oLAAA,CAAA,SAAM,AAAD;IACX,QAAQ,GAAG,CAAC,0DAA0D,IAAI,OAAO,CAAC,SAAS;AAC7F;AAEA,aAAa;AACb,IAAI,KAAK;IACP,IAAI;QACF,aAAa;QACb,KAAK,CAAA,GAAA,iKAAA,CAAA,eAAY,AAAD,EAAE;QAClB,QAAQ,GAAG,CAAC;IACd,EAAE,OAAO,GAAQ;QACf,QAAQ,KAAK,CAAC,mDAAmD,GAAG;IACtE;AACF,OAAO;IACH,QAAQ,KAAK,CAAC;AAClB","debugId":null}},
    {"offset": {"line": 264, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/genkit.ts"],"sourcesContent":["\nimport '@/lib/firebase'; // Ensure Firebase is initialized early\nimport {genkit} from 'genkit';\nimport {googleAI} from '@genkit-ai/googleai'; // Impor plugin Google AI\n\nexport const ai = genkit({\n  plugins: [\n    googleAI(), // Gunakan plugin Google AI\n  ],\n  model: 'googleai/gemini-1.5-flash-latest', // Mengubah ke model yang lebih stabil\n  // Opsi telemetry tidak lagi dikonfigurasi di sini untuk Genkit v1.x\n  // Jika butuh logging, konfigurasi dilakukan secara berbeda atau via environment.\n});\n"],"names":[],"mappings":";;;AACA,8MAAyB,uCAAuC;AAChE;AAAA;AACA,8TAA8C,yBAAyB;AAAvE;;;;AAEO,MAAM,KAAK,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE;IACvB,SAAS;QACP,CAAA,GAAA,2KAAA,CAAA,WAAQ,AAAD;KACR;IACD,OAAO;AAGT","debugId":null}},
    {"offset": {"line": 295, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/firebase-admin.ts"],"sourcesContent":["\nimport * as admin from 'firebase-admin';\n\n// Minimal logging\nconsole.log(\"[firebase-admin.ts] Initializing Firebase Admin SDK...\");\n\nif (!admin.apps.length) {\n  try {\n    // When deployed to App Hosting or running with emulators (e.g., via `firebase emulators:start`),\n    // the SDK should auto-configure based on the environment.\n    // For local development outside emulators, you might need to set\n    // GOOGLE_APPLICATION_CREDENTIALS environment variable pointing to your service account key JSON file.\n    admin.initializeApp();\n    console.log('[firebase-admin.ts] Firebase Admin SDK initialized successfully.');\n    if (admin.instanceId()) { // Check if instanceId is available\n      console.log('[firebase-admin.ts] Firebase Admin App Name:', admin.app().name);\n    }\n  } catch (e:any) {\n    console.error('[firebase-admin.ts] Firebase Admin SDK initialization failed. Details:', e.message);\n    console.error('[firebase-admin.ts] Ensure your environment is configured correctly for Firebase Admin (e.g., GOOGLE_APPLICATION_CREDENTIALS for local dev, or running within a Firebase/GCP environment).');\n    // Depending on your error handling strategy, you might want to re-throw or handle this.\n    // For now, we'll let it proceed, but db/auth might be undefined.\n  }\n} else {\n  console.log('[firebase-admin.ts] Firebase Admin SDK already initialized. Using existing app.');\n}\n\nlet adminDb: admin.firestore.Firestore;\nlet adminAuth: admin.auth.Auth;\n\ntry {\n  adminDb = admin.firestore();\n  console.log('[firebase-admin.ts] Firestore Admin instance obtained.');\n} catch (e:any) {\n  console.error('[firebase-admin.ts] FAILED to get Firestore Admin instance:', e?.message);\n  // @ts-ignore\n  adminDb = undefined; \n}\n\ntry {\n  adminAuth = admin.auth();\n  console.log('[firebase-admin.ts] Auth Admin instance obtained.');\n} catch (e:any) {\n  console.error('[firebase-admin.ts] FAILED to get Auth Admin instance:', e?.message);\n  // @ts-ignore\n  adminAuth = undefined;\n}\n\n\nexport { adminDb, adminAuth };\n"],"names":[],"mappings":";;;;AACA;;AAEA,kBAAkB;AAClB,QAAQ,GAAG,CAAC;AAEZ,IAAI,CAAC,2HAAA,CAAA,OAAU,CAAC,MAAM,EAAE;IACtB,IAAI;QACF,iGAAiG;QACjG,0DAA0D;QAC1D,iEAAiE;QACjE,sGAAsG;QACtG,CAAA,GAAA,2HAAA,CAAA,gBAAmB,AAAD;QAClB,QAAQ,GAAG,CAAC;QACZ,IAAI,CAAA,GAAA,2HAAA,CAAA,aAAgB,AAAD,KAAK;YACtB,QAAQ,GAAG,CAAC,gDAAgD,CAAA,GAAA,2HAAA,CAAA,MAAS,AAAD,IAAI,IAAI;QAC9E;IACF,EAAE,OAAO,GAAO;QACd,QAAQ,KAAK,CAAC,0EAA0E,EAAE,OAAO;QACjG,QAAQ,KAAK,CAAC;IACd,wFAAwF;IACxF,iEAAiE;IACnE;AACF,OAAO;IACL,QAAQ,GAAG,CAAC;AACd;AAEA,IAAI;AACJ,IAAI;AAEJ,IAAI;IACF,UAAU,CAAA,GAAA,2HAAA,CAAA,YAAe,AAAD;IACxB,QAAQ,GAAG,CAAC;AACd,EAAE,OAAO,GAAO;IACd,QAAQ,KAAK,CAAC,+DAA+D,GAAG;IAChF,aAAa;IACb,UAAU;AACZ;AAEA,IAAI;IACF,YAAY,CAAA,GAAA,2HAAA,CAAA,OAAU,AAAD;IACrB,QAAQ,GAAG,CAAC;AACd,EAAE,OAAO,GAAO;IACd,QAAQ,KAAK,CAAC,0DAA0D,GAAG;IAC3E,aAAa;IACb,YAAY;AACd","debugId":null}},
    {"offset": {"line": 348, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/tools/extractMotorInfoTool.ts"],"sourcesContent":["\n'use server';\n/**\n * @fileOverview Genkit tool for extracting motorcycle information from text.\n * - extractMotorInfoTool - The Genkit tool definition.\n */\n\nimport { ai } from '@/ai/genkit';\nimport { z } from 'genkit';\nimport { adminDb } from '@/lib/firebase-admin'; // Pastikan file ini ada dan terkonfigurasi\n\n// Skema input untuk tool\nconst ExtractMotorInfoInputSchema = z.object({\n  text: z.string().describe('Teks dari pengguna yang mungkin berisi nama atau deskripsi motor.'),\n});\nexport type ExtractMotorInfoInput = z.infer<typeof ExtractMotorInfoInputSchema>;\n\n// Skema output untuk tool\nconst ExtractMotorInfoOutputSchema = z.object({\n  brand: z.string().describe('Merek motor yang terdeteksi.'),\n  model: z.string().describe('Model motor yang terdeteksi.'),\n  size: z.enum(['S', 'M', 'L', 'XL']).describe('Ukuran motor yang terdeteksi (S, M, L, XL).'),\n});\nexport type ExtractMotorInfoOutput = z.infer<typeof ExtractMotorInfoOutputSchema>;\n\n// Definisi tool Genkit\nexport const extractMotorInfoTool = ai.defineTool(\n  {\n    name: 'extractMotorInfoTool', // Nama tool di Genkit, bisa beda dari nama variabel\n    description: 'Mendeteksi merek, model, dan ukuran motor dari teks deskriptif pengguna dengan mencocokkan ke database tipe kendaraan.',\n    inputSchema: ExtractMotorInfoInputSchema,\n    outputSchema: ExtractMotorInfoOutputSchema,\n  },\n  async (input: ExtractMotorInfoInput): Promise<ExtractMotorInfoOutput> => {\n    const cleanText = input.text.toLowerCase().trim();\n    console.log(`[extractMotorInfoTool] Input text: \"${input.text}\", Cleaned text: \"${cleanText}\"`);\n\n    if (!cleanText) {\n      console.log('[extractMotorInfoTool] Input text is empty. Throwing error.');\n      throw new Error('Teks input kosong, tidak bisa mendeteksi motor.');\n    }\n\n    try {\n      const vehicleTypesSnapshot = await adminDb.collection('vehicleTypes').get();\n      console.log(`[extractMotorInfoTool] Raw snapshot size from 'vehicleTypes': ${vehicleTypesSnapshot.size}`);\n\n      if (vehicleTypesSnapshot.empty) {\n        console.log('[extractMotorInfoTool] Collection \"vehicleTypes\" is empty or does not exist in Firestore.');\n        throw new Error('Database tipe kendaraan kosong atau tidak ditemukan.');\n      }\n\n      const mappedVehicleTypes = vehicleTypesSnapshot.docs.map(doc => {\n        const data = doc.data();\n        const validationErrorMessages: string[] = [];\n\n        if (!data.brand || typeof data.brand !== 'string') {\n            validationErrorMessages.push('field \"brand\" is missing or not a string');\n        }\n        if (!data.model || typeof data.model !== 'string') {\n            validationErrorMessages.push('field \"model\" is missing or not a string');\n        }\n        if (!data.size || typeof data.size !== 'string' || !['S', 'M', 'L', 'XL'].includes(data.size)) {\n            validationErrorMessages.push('field \"size\" is missing, not a string, or not S/M/L/XL');\n        }\n        if (!data.aliases || !Array.isArray(data.aliases)) {\n            validationErrorMessages.push('field \"aliases\" is missing or not an array');\n        } else if (!data.aliases.every((a: any) => typeof a === 'string')) {\n            validationErrorMessages.push('field \"aliases\" contains non-string elements');\n        }\n\n        if (validationErrorMessages.length > 0) {\n            console.warn(`[extractMotorInfoTool] Dokumen ${doc.id} di 'vehicleTypes' GAGAL VALIDASI. Alasan: ${validationErrorMessages.join('; ')}. Data mentah: ${JSON.stringify(data)}. Dokumen ini akan dilewati.`);\n            return null; \n        }\n        \n        return {\n          id: doc.id,\n          brand: data.brand as string,\n          model: data.model as string,\n          size: data.size as 'S' | 'M' | 'L' | 'XL',\n          aliases: (data.aliases as string[]).map(alias => alias.toLowerCase()),\n        };\n      });\n      \n      console.log(`[extractMotorInfoTool] Mapped vehicle types (before filtering nulls): ${mappedVehicleTypes.length}`);\n      const allVehicleTypes = mappedVehicleTypes.filter(item => item !== null) as { id: string; brand: string; model: string; size: 'S' | 'M' | 'L' | 'XL'; aliases: string[]; }[];\n      \n      console.log(`[extractMotorInfoTool] Total valid vehicle types after filtering: ${allVehicleTypes.length}.`);\n\n      if (allVehicleTypes.length === 0) {\n        console.log('[extractMotorInfoTool] No valid vehicle types found after filtering. Check Firestore data format and console warnings above for details on invalid documents.');\n        throw new Error('Tidak ada data tipe kendaraan yang valid di database. Periksa format data di Firestore dan log peringatan di konsol.');\n      }\n\n      for (const vehicleType of allVehicleTypes) {\n        // console.log(`[extractMotorInfoTool] Checking vehicle: ${vehicleType.brand} ${vehicleType.model}, Aliases: ${vehicleType.aliases.join(', ')}`);\n        for (const alias of vehicleType.aliases) {\n          if (cleanText.includes(alias)) {\n            console.log(`[extractMotorInfoTool] !!! MATCH FOUND !!! Alias \"${alias}\" (from vehicle: ${vehicleType.brand} ${vehicleType.model}) found in cleaned text: \"${cleanText}\"`);\n            return {\n              brand: vehicleType.brand,\n              model: vehicleType.model,\n              size: vehicleType.size,\n            };\n          }\n        }\n      }\n\n      console.log('[extractMotorInfoTool] No match found for the input text after checking all vehicle types and aliases.');\n      throw new Error('Motor tidak dikenali dari teks yang diberikan. Pastikan alias di database mencakup variasi nama motor tersebut.');\n\n    } catch (error: any) {\n      console.error('[extractMotorInfoTool] Error during execution:', error);\n      if (error instanceof Error) {\n        throw new Error(`Kesalahan pada tool extractMotorInfo: ${error.message}`);\n      }\n      throw new Error(`Terjadi kesalahan internal pada tool extractMotorInfo: ${String(error)}`);\n    }\n  }\n);\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 475, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/tools/searchServiceByKeywordTool.ts"],"sourcesContent":["'use server';\n/**\n * @fileOverview Genkit tool for searching services by keyword and optional size.\n * - searchServiceByKeywordTool - The Genkit tool definition.\n * - SearchServiceInput - Input schema for the tool.\n * - SearchServiceOutput - Output schema for the tool.\n */\nimport { ai } from '@/ai/genkit';\nimport { z } from 'genkit'; // Genkit's Zod\nimport { adminDb } from '@/lib/firebase-admin';\nimport type { ServiceProduct } from '@/app/(app)/services/page'; // Assuming this type is suitable\n\nconst SearchServiceInputSchema = z.object({\n  keyword: z.string().describe(\"Kata kunci untuk mencari layanan, mis. 'cuci', 'coating', 'nmax'.\") ,\n  size: z.enum(['S', 'M', 'L', 'XL']).optional().describe(\"Ukuran motor (S, M, L, XL) jika spesifik.\"),\n});\nexport type SearchServiceInput = z.infer<typeof SearchServiceInputSchema>;\n\nconst SearchServiceOutputSchema = z.object({\n  name: z.string().describe(\"Nama layanan yang ditemukan.\"),\n  description: z.string().optional().describe(\"Deskripsi layanan.\"),\n  price: z.number().optional().describe(\"Harga layanan untuk ukuran yang cocok (jika ada).\"),\n  size: z.enum(['S', 'M', 'L', 'XL']).optional().describe(\"Ukuran motor yang dicari (jika relevan dengan varian).\"),\n  duration: z.string().optional().describe(\"Estimasi durasi pengerjaan layanan.\"),\n  variantMatched: z.string().optional().describe(\"Nama varian yang cocok (jika ada dan relevan).\")\n});\nexport type SearchServiceOutput = z.infer<typeof SearchServiceOutputSchema>;\n\nexport const searchServiceByKeywordTool = ai.defineTool(\n  {\n    name: 'searchServiceByKeywordTool',\n    description: 'Cari layanan berdasarkan keyword dari pelanggan dan ukuran motor (opsional). Berguna untuk menemukan layanan yang relevan beserta harganya.',\n    inputSchema: SearchServiceInputSchema,\n    outputSchema: SearchServiceOutputSchema,\n  },\n  async (input) => {\n    const { keyword, size } = input;\n    console.log(`[searchServiceByKeywordTool] Searching for keyword: \"${keyword}\", size: \"${size || 'any'}\"`);\n    \n    const snapshot = await adminDb.collection('services').get();\n    \n    const servicesFromDb: ServiceProduct[] = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as ServiceProduct));\n\n    if (servicesFromDb.length === 0) {\n      console.warn('[searchServiceByKeywordTool] No services found in the database.');\n      throw new Error('Tidak ada layanan yang terdaftar di database.');\n    }\n\n    const keywordLower = keyword.toLowerCase();\n    let bestMatch: ServiceProduct | undefined = undefined;\n    let highestScore = -1;\n\n    for (const svc of servicesFromDb) {\n      let currentScore = 0;\n      const nameLower = svc.name.toLowerCase();\n      \n      if (nameLower.includes(keywordLower)) {\n        currentScore += 10;\n        if (nameLower === keywordLower) currentScore += 15; // Stronger match for exact name\n      }\n      if (svc.description?.toLowerCase().includes(keywordLower)) {\n        currentScore += 3;\n      }\n      if (svc.category?.toLowerCase().includes(keywordLower)) {\n        currentScore += 2;\n      }\n      // Consider aliases from ServiceProduct if it exists and is an array of strings\n      if (svc.aliases && Array.isArray(svc.aliases)) {\n        if (svc.aliases.some(alias => alias.toLowerCase().includes(keywordLower))) {\n           currentScore += 8;\n           if (svc.aliases.some(alias => alias.toLowerCase() === keywordLower)) currentScore += 7; // Exact alias match\n        }\n      }\n      // Consider variant names in scoring too\n      if (svc.variants && svc.variants.length > 0) {\n        svc.variants.forEach(variant => {\n          if (variant.name.toLowerCase().includes(keywordLower)) {\n            currentScore += 5; // Add score if keyword matches a variant name\n          }\n        });\n      }\n\n      if (currentScore > highestScore) {\n        highestScore = currentScore;\n        bestMatch = svc;\n      }\n    }\n    \n    if (!bestMatch || highestScore === 0) {\n      console.log(`[searchServiceByKeywordTool] No service found matching keyword: \"${keyword}\"`);\n      // Returning a structured error or a specific \"not found\" object might be better for the AI\n      // For now, throwing error as in original user code.\n      throw new Error(`Layanan tidak ditemukan untuk kata kunci \"${keyword}\".`);\n    }\n    console.log(`[searchServiceByKeywordTool] Best match found: ${bestMatch.name} with score ${highestScore}`);\n\n    let finalPrice: number | undefined = undefined;\n    let matchedVariantName: string | undefined = undefined;\n    let finalDuration = bestMatch.estimatedDuration || undefined;\n\n    if (bestMatch.variants && bestMatch.variants.length > 0) {\n      let variantToUse;\n      if (size) {\n        // Attempt to find a variant that explicitly mentions the size\n        variantToUse = bestMatch.variants.find(variant => \n          variant.name.toLowerCase().includes(size.toLowerCase())\n        );\n        if (variantToUse) {\n          console.log(`[searchServiceByKeywordTool] Matched variant by size \"${size}\": ${variantToUse.name}`);\n        } else {\n          console.log(`[searchServiceByKeywordTool] No variant specifically matched size \"${size}\", considering first variant or base price.`);\n        }\n      }\n\n      // If size-specific variant not found, or no size provided, use the first variant.\n      // Or, if base price is relevant and variants are add-ons, this logic might need adjustment.\n      // For now, if a size-specific variant is found, use it. Otherwise, if variants exist, pick first.\n      if (variantToUse) {\n        finalPrice = variantToUse.price;\n        matchedVariantName = variantToUse.name;\n        finalDuration = variantToUse.estimatedDuration || finalDuration;\n      } else if (bestMatch.variants.length > 0) {\n        // Fallback to first variant if no size match or no size provided, but variants exist.\n        // This mirrors user's original logic of `bestMatch.variants?.[0]` somewhat.\n        // finalPrice = bestMatch.variants[0].price;\n        // matchedVariantName = bestMatch.variants[0].name;\n        // finalDuration = bestMatch.variants[0].estimatedDuration || finalDuration;\n        // console.log(`[searchServiceByKeywordTool] No size specific match, or no size provided. Using first variant: ${matchedVariantName}`);\n        // Let's default to base price if no specific variant matched, and only use first variant if base price is 0/undefined\n        if (bestMatch.price && bestMatch.price > 0) {\n            finalPrice = bestMatch.price;\n        } else {\n            finalPrice = bestMatch.variants[0].price;\n            matchedVariantName = bestMatch.variants[0].name;\n            finalDuration = bestMatch.variants[0].estimatedDuration || finalDuration;\n            console.log(`[searchServiceByKeywordTool] Base price is 0 or undefined. Using first variant: ${matchedVariantName}`);\n        }\n\n      } else { // No variants, use base price\n         finalPrice = bestMatch.price;\n      }\n    } else {\n      // No variants for the service\n      finalPrice = bestMatch.price;\n    }\n    \n    console.log(`[searchServiceByKeywordTool] Final price for \"${bestMatch.name}\" (Size: ${size || 'any'}, Variant: ${matchedVariantName || 'N/A'}): ${finalPrice}`);\n\n    if (finalPrice === undefined) {\n        console.warn(`[searchServiceByKeywordTool] Could not determine a price for \"${bestMatch.name}\" with keyword \"${keyword}\" and size \"${size}\".`);\n    }\n\n    return {\n      name: bestMatch.name,\n      description: bestMatch.description || undefined,\n      price: finalPrice,\n      size: size, // Echo back the input size\n      duration: finalDuration,\n      variantMatched: matchedVariantName,\n    };\n  }\n);\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 645, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/types/ai/cs-whatsapp-reply.ts"],"sourcesContent":["\nimport { z } from 'genkit';\n\nexport const ChatMessageSchema = z.object({\n  role: z.enum(['user', 'model']), // 'user' for customer/CS agent, 'model' for AI's previous replies\n  content: z.string(),\n});\nexport type ChatMessage = z.infer<typeof ChatMessageSchema>;\n\nexport const WhatsAppReplyInputSchema = z.object({\n  customerMessage: z.string().describe('Pesan yang diterima dari pelanggan melalui WhatsApp, atau pertanyaan dari staf CS.'),\n  senderNumber: z.string().optional().describe('Nomor WhatsApp pengirim pesan (pelanggan).'),\n  chatHistory: z.array(ChatMessageSchema).optional().describe('Riwayat percakapan sebelumnya antara pelanggan dan AI/staf CS.'),\n  agentBehavior: z.string().optional().describe('Perilaku agen AI yang diinginkan, mis. \"Ramah & Membantu\".'),\n  knowledgeBase: z.string().optional().describe('Panduan tingkat tinggi untuk AI. Detail pengetahuan spesifik akan diambil melalui tools.'),\n  currentDate: z.string().optional().describe('Tanggal saat ini dalam format YYYY-MM-DD. Berguna untuk konteks booking.'),\n  currentTime: z.string().optional().describe('Waktu saat ini dalam format HH:MM (24 jam). Berguna untuk konteks booking.'),\n  tomorrowDate: z.string().optional().describe('Tanggal besok dalam format YYYY-MM-DD. Berguna untuk konteks booking.'),\n  dayAfterTomorrowDate: z.string().optional().describe('Tanggal lusa (besoknya besok) dalam format YYYY-MM-DD. Berguna untuk konteks booking.'),\n});\nexport type WhatsAppReplyInput = z.infer<typeof WhatsAppReplyInputSchema>;\n\nexport const WhatsAppReplyOutputSchema = z.object({\n  suggestedReply: z.string().describe('Saran balasan yang dihasilkan AI untuk dikirim ke pelanggan.'),\n});\nexport type WhatsAppReplyOutput = z.infer<typeof WhatsAppReplyOutputSchema>;\n    \n"],"names":[],"mappings":";;;;;AACA;AAAA;;AAEO,MAAM,oBAAoB,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACxC,MAAM,uIAAA,CAAA,IAAC,CAAC,IAAI,CAAC;QAAC;QAAQ;KAAQ;IAC9B,SAAS,uIAAA,CAAA,IAAC,CAAC,MAAM;AACnB;AAGO,MAAM,2BAA2B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC/C,iBAAiB,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACrC,cAAc,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;IAC7C,aAAa,uIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,mBAAmB,QAAQ,GAAG,QAAQ,CAAC;IAC5D,eAAe,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;IAC9C,eAAe,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;IAC9C,aAAa,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;IAC5C,aAAa,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;IAC5C,cAAc,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;IAC7C,sBAAsB,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;AACvD;AAGO,MAAM,4BAA4B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAChD,gBAAgB,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AACtC","debugId":null}},
    {"offset": {"line": 680, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/cs-whatsapp-reply-flow.ts"],"sourcesContent":["\n'use server';\n/**\n * @fileOverview AI flow for WhatsApp customer service replies.\n * - whatsAppReplyFlowSimplified - Main flow for generating WhatsApp replies.\n */\n\nimport { ai } from '@/ai/genkit';\nimport { z } from 'genkit'; // Menggunakan z dari genkit\nimport { extractMotorInfoTool } from '@/ai/tools/extractMotorInfoTool';\nimport { searchServiceByKeywordTool } from '@/ai/tools/searchServiceByKeywordTool'; // Tool baru untuk cari layanan\nimport type { WhatsAppReplyInput, WhatsAppReplyOutput, ChatMessage } from '@/types/ai/cs-whatsapp-reply';\nimport { WhatsAppReplyInputSchema, WhatsAppReplyOutputSchema } from '@/types/ai/cs-whatsapp-reply';\n\n// Prompt Zoya yang diperbarui\nconst promptZoya = `\nAnda adalah Zoya, Customer Service AI dari QLAB Moto Detailing.\n\nGaya bahasa:\n- Santai dan akrab, pakai sapaan seperti \"bro\", \"kak\", \"mas\".\n- Tetap informatif dan jelas.\n\nTool yang tersedia:\n1.  \\`extractMotorInfoTool\\`: Untuk mendeteksi merek, model, dan ukuran motor dari teks. Input: {\"text\": \"deskripsi motor\"}. Output: {\"brand\": \"...\", \"model\": \"...\", \"size\": \"S/M/L/XL\"}\n2.  \\`searchServiceByKeywordTool\\`: Untuk mencari detail layanan/produk berdasarkan kata kunci dan (opsional) ukuran motor. Input: {\"keyword\": \"nama layanan/produk\", \"size\": \"S/M/L/XL\"}. Output: {\"name\": \"...\", \"description\": \"...\", \"price\": ..., \"duration\": \"...\", \"variantMatched\": \"...\"}\n\nTugas kamu:\n1.  Pahami permintaan pelanggan. Identifikasi apakah mereka bertanya tentang layanan/produk, ingin booking, atau hal lain.\n\n2.  **Jika pelanggan bertanya tentang layanan/produk SPESIFIK (misalnya \"coating\", \"cuci motor\", \"harga nmax coating\", \"info detailing\"):**\n    a.  **Deteksi Motor Dulu (Jika Ada):** Jika pelanggan menyebutkan jenis motor (misalnya \"NMAX\", \"Vario\", \"Beat\"), gunakan \\`extractMotorInfoTool\\` untuk mendapatkan \\`brand\\`, \\`model\\`, dan \\`size\\` motornya.\n        Contoh: Jika pelanggan bilang \"coating NMAX berapa?\", panggil \\`extractMotorInfoTool\\` dengan input \\`{\"text\": \"NMAX\"}\\`.\n    b.  **Cari Layanan/Produk:**\n        *   Gunakan \\`searchServiceByKeywordTool\\`. \\`keyword\\`-nya adalah nama layanan/produk yang ditanyakan (mis. \"coating\", \"cuci motor\", \"detailing\").\n        *   Jika kamu berhasil mendapatkan \\`size\\` motor dari langkah 2a, sertakan \\`size\\` tersebut saat memanggil \\`searchServiceByKeywordTool\\`.\n        *   Jika pelanggan TIDAK menyebutkan motor, panggil \\`searchServiceByKeywordTool\\` HANYA dengan \\`keyword\\` (tanpa \\`size\\`).\n    c.  **Formulasikan Jawaban:**\n        *   **Jika motor TIDAK disebutkan di awal (dan kamu memanggil tool pencarian layanan TANPA size):**\n            *   Jika tool pencarian layanan (\\`searchServiceByKeywordTool\\`) mengembalikan hasil, gunakan \\`description\\` dari output tool tersebut untuk menjelaskan layanan/produk.\n            *   Setelah menjelaskan, TANYAKAN jenis motor pelanggan agar bisa memberikan harga akurat. Contoh: \"Coating itu (ambil dari deskripsi tool). Nah, buat motor apa nih bro? Biar Zoya bisa kasih info harga yang pas. Motornya doff atau glossy juga boleh diinfoin sekalian.\"\n            *   Jika tool pencarian layanan TIDAK menemukan info, jawab dengan sopan bahwa kamu belum nemu info detailnya dan tanya motornya apa.\n        *   **Jika motor SUDAH disebutkan (dan kamu memanggil tool pencarian layanan DENGAN size):**\n            *   Jika tool pencarian layanan (\\`searchServiceByKeywordTool\\`) mengembalikan hasil, sebutkan \\`name\\` (nama layanan/produk dari tool, mungkin dengan varian jika ada), \\`price\\` (harga dari tool), dan jika ada \\`duration\\` (estimasi durasi dari tool).\n            *   Contoh: \"Oke bro, untuk NMAX (model dari extractMotorInfo) itu coatingnya pakai (nama layanan dari searchService) harganya Rp XXX (harga dari searchService), pengerjaannya sekitar YYY (durasi dari searchService). Minat sekalian booking?\"\n            *   Jika tool pencarian layanan TIDAK menemukan info harga/layanan yang cocok dengan ukuran motor tersebut, informasikan bahwa harga spesifik untuk ukuran itu belum ketemu, tapi bisa kasih gambaran umum layanannya (ambil dari deskripsi jika ada).\n        *   **PENTING:** Jika \\`searchServiceByKeywordTool\\` mengembalikan \\`price\\` undefined atau 0 (dan bukan memang gratis), JANGAN sebutkan harganya. Lebih baik katakan, \"Untuk harga pastinya tergantung ukuran dan jenis motornya nih, bro. Motornya apa ya?\" atau \"Zoya belum nemu harga pastinya untuk itu, motornya apa bro?\". JANGAN mengarang harga.\n\n3.  **Jika pelanggan bertanya tentang layanan secara umum tanpa detail motor (misal \"coating apa aja?\", \"kalau detailing gimana?\"):**\n    Prioritaskan untuk menjelaskan layanan tersebut dulu menggunakan deskripsi dari \\`searchServiceByKeywordTool\\` (panggil dengan keyword layanan saja, tanpa size). Setelah itu, baru tanyakan motornya untuk info harga.\n\n4.  **Jika pelanggan mau booking (setelah dapat info harga atau langsung minta booking):**\n    Kumpulkan data berikut: Nama, No HP, Tanggal, Jam, Jenis Motor (jika sudah diketahui dari tool \\`extractMotorInfoTool\\` atau dari konfirmasi pelanggan).\n    Sampaikan bahwa staf kami akan menghubungi untuk konfirmasi final booking.\n\n5.  **Umum:**\n    *   Jika tidak yakin atau permintaan di luar kemampuanmu, arahkan pelanggan ke CS manusia.\n    *   Selalu gunakan sapaan akrab.\n\nFormat output HARUS berupa JSON:\n{ \"suggestedReply\": \"Teks balasan disini\" }\n\nContoh interaksi (pelanggan tanya layanan tanpa motor):\nPelanggan: \"Coating berapaan ya?\"\nAI (setelah panggil searchServiceByKeywordTool dengan keyword \"coating\"):\n{ \"suggestedReply\": \"Coating itu bikin motor kinclong plus terlindungi bro, dari debu, air, sama goresan halus. Prosesnya meliputi pembersihan detail, koreksi cat kalau perlu, terus aplikasi lapisan coatingnya. Nah, buat motor apa nih? Beda ukuran motor, beda juga harganya soalnya.\" }\n\nChat customer terbaru:\nuser: {{{customerMessage}}}\n\nRiwayat sebelumnya:\n{{#if chatHistory.length}}\n{{#each chatHistory}}\n{{this.role}}: {{this.content}}\n{{/each}}\n{{/if}}\n\nTanggal hari ini: {{{currentDate}}}, waktu: {{{currentTime}}}\nBesok: {{{tomorrowDate}}}, Lusa: {{{dayAfterTomorrowDate}}}\n`;\n\n\n/**\n * Define prompt untuk Zoya dengan tool yang diperlukan\n */\nconst replyPromptSimplified = ai.definePrompt({\n  name: 'whatsAppReplyPromptSimplified',\n  input: { schema: WhatsAppReplyInputSchema },\n  output: { schema: WhatsAppReplyOutputSchema },\n  tools: [extractMotorInfoTool, searchServiceByKeywordTool], // Tambahkan searchServiceByKeywordTool\n  prompt: promptZoya,\n});\n\n/**\n * Flow utama untuk digunakan di API/function/genkit handler\n */\nexport const whatsAppReplyFlowSimplified = ai.defineFlow(\n  {\n    name: 'whatsAppReplyFlowSimplified',\n    inputSchema: WhatsAppReplyInputSchema,\n    outputSchema: WhatsAppReplyOutputSchema,\n  },\n  async (input: WhatsAppReplyInput): Promise<WhatsAppReplyOutput> => {\n    console.log(\"[CS-FLOW] whatsAppReplyFlowSimplified input:\", JSON.stringify(input, null, 2));\n    try {\n      const { output } = await replyPromptSimplified(input);\n      if (!output || !output.suggestedReply) { \n        console.error('[CS-FLOW] ❌ Gagal mendapatkan balasan dari AI atau output tidak sesuai skema (output atau suggestedReply null/undefined). Mengembalikan default.');\n        return { suggestedReply: \"Maaf, Zoya lagi bingung nih. Bisa diulang pertanyaannya atau coba beberapa saat lagi?\" };\n      }\n      // Output should already be validated by definePrompt's outputSchema based on Zod.\n      console.log(\"[CS-FLOW] whatsAppReplyFlowSimplified output dari prompt:\", output);\n      return output;\n    } catch (e: any) {\n      console.error('[CS-FLOW] ❌ Error saat menjalankan prompt AI atau memproses outputnya:', e);\n      const errorMessage = e instanceof Error ? e.message : String(e);\n      return { suggestedReply: `Duh, Zoya lagi pusing tujuh keliling (${errorMessage.substring(0,50)}...). Tanya lagi nanti ya, bro!` };\n    }\n  }\n);\n\nexport async function generateWhatsAppReply(input: WhatsAppReplyInput): Promise<WhatsAppReplyOutput> {\n  const flowInput: WhatsAppReplyInput = {\n    customerMessage: input.customerMessage,\n    senderNumber: input.senderNumber,\n    chatHistory: input.chatHistory || [],\n    currentDate: input.currentDate,\n    currentTime: input.currentTime,\n    tomorrowDate: input.tomorrowDate,\n    dayAfterTomorrowDate: input.dayAfterTomorrowDate,\n  };\n  return whatsAppReplyFlowSimplified(flowInput);\n}\n"],"names":[],"mappings":";;;;;;AAEA;;;CAGC,GAED;AAEA;AACA,+PAAoF,+BAA+B;AAEnH;;;;;;;;AAEA,8BAA8B;AAC9B,MAAM,aAAa,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+DpB,CAAC;AAGD;;CAEC,GACD,MAAM,wBAAwB,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC5C,MAAM;IACN,OAAO;QAAE,QAAQ,6IAAA,CAAA,2BAAwB;IAAC;IAC1C,QAAQ;QAAE,QAAQ,6IAAA,CAAA,4BAAyB;IAAC;IAC5C,OAAO;QAAC,0IAAA,CAAA,uBAAoB;QAAE,gJAAA,CAAA,6BAA0B;KAAC;IACzD,QAAQ;AACV;AAKO,MAAM,8BAA8B,mHAAA,CAAA,KAAE,CAAC,UAAU,CACtD;IACE,MAAM;IACN,aAAa,6IAAA,CAAA,2BAAwB;IACrC,cAAc,6IAAA,CAAA,4BAAyB;AACzC,GACA,OAAO;IACL,QAAQ,GAAG,CAAC,gDAAgD,KAAK,SAAS,CAAC,OAAO,MAAM;IACxF,IAAI;QACF,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,sBAAsB;QAC/C,IAAI,CAAC,UAAU,CAAC,OAAO,cAAc,EAAE;YACrC,QAAQ,KAAK,CAAC;YACd,OAAO;gBAAE,gBAAgB;YAAwF;QACnH;QACA,kFAAkF;QAClF,QAAQ,GAAG,CAAC,6DAA6D;QACzE,OAAO;IACT,EAAE,OAAO,GAAQ;QACf,QAAQ,KAAK,CAAC,0EAA0E;QACxF,MAAM,eAAe,aAAa,QAAQ,EAAE,OAAO,GAAG,OAAO;QAC7D,OAAO;YAAE,gBAAgB,CAAC,sCAAsC,EAAE,aAAa,SAAS,CAAC,GAAE,IAAI,+BAA+B,CAAC;QAAC;IAClI;AACF;AAGK,eAAe,sBAAsB,KAAyB;IACnE,MAAM,YAAgC;QACpC,iBAAiB,MAAM,eAAe;QACtC,cAAc,MAAM,YAAY;QAChC,aAAa,MAAM,WAAW,IAAI,EAAE;QACpC,aAAa,MAAM,WAAW;QAC9B,aAAa,MAAM,WAAW;QAC9B,cAAc,MAAM,YAAY;QAChC,sBAAsB,MAAM,oBAAoB;IAClD;IACA,OAAO,4BAA4B;AACrC;;;IApCa;IAyBS;;AAzBT,+OAAA;AAyBS,+OAAA","debugId":null}},
    {"offset": {"line": 831, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/.next-internal/server/app/%28app%29/ai-cs-assistant/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {generateWhatsAppReply as '4053660f6447b38038e1d20965a3df3cd57a2a7b51'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA","debugId":null}},
    {"offset": {"line": 895, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/%28app%29/ai-cs-assistant/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/(app)/ai-cs-assistant/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/(app)/ai-cs-assistant/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAA0S,GACvU,wEACA","debugId":null}},
    {"offset": {"line": 909, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/%28app%29/ai-cs-assistant/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/(app)/ai-cs-assistant/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/(app)/ai-cs-assistant/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAsR,GACnT,oDACA","debugId":null}},
    {"offset": {"line": 923, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}